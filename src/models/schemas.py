from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional

import pandas as pd


class Signal(Enum):
    """Trading signal types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class OrderType(Enum):
    """Order types for trading."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"


class OrderSide(Enum):
    """Order side (buy or sell)."""
    BUY = "BUY"
    SELL = "SELL"


@dataclass
class OHLCV:
    """Open, High, Low, Close, Volume data for a single bar."""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    ticker: str


@dataclass
class OHLCVSeries:
    """Time series of OHLCV data for a ticker."""
    ticker: str
    data: pd.DataFrame  # DataFrame with columns: open, high, low, close, volume, indexed by datetime

    @property
    def start_date(self) -> datetime:
        return self.data.index.min()

    @property
    def end_date(self) -> datetime:
        return self.data.index.max()

    def __len__(self) -> int:
        return len(self.data)


@dataclass
class Trade:
    """Represents an executed trade."""
    ticker: str
    side: OrderSide
    quantity: int
    price: float
    timestamp: datetime
    commission: float = 0.0

    @property
    def total_value(self) -> float:
        """Total value of the trade including commission."""
        return (self.quantity * self.price) + self.commission


@dataclass
class Position:
    """Represents a current position in a security."""
    ticker: str
    quantity: int
    avg_cost: float

    @property
    def market_value(self) -> float:
        """Calculate market value at average cost."""
        return self.quantity * self.avg_cost

    def update(self, trade: Trade) -> None:
        """Update position based on a trade."""
        if trade.side == OrderSide.BUY:
            total_cost = (self.quantity * self.avg_cost) + (trade.quantity * trade.price)
            self.quantity += trade.quantity
            self.avg_cost = total_cost / self.quantity if self.quantity > 0 else 0
        else:  # SELL
            self.quantity -= trade.quantity
            if self.quantity == 0:
                self.avg_cost = 0


@dataclass
class TradeSignal:
    """A trading signal generated by a strategy."""
    ticker: str
    signal: Signal
    timestamp: datetime
    price: float
    strength: float = 1.0  # Signal strength/confidence (0-1)
    metadata: dict = field(default_factory=dict)


@dataclass
class Portfolio:
    """Represents a portfolio with cash and positions."""
    cash: float
    positions: dict[str, Position] = field(default_factory=dict)

    @property
    def total_value(self) -> float:
        """Total portfolio value (cash + positions)."""
        positions_value = sum(
            pos.quantity * pos.avg_cost for pos in self.positions.values()
        )
        return self.cash + positions_value

    def get_position(self, ticker: str) -> Optional[Position]:
        """Get position for a ticker, or None if not held."""
        return self.positions.get(ticker)


@dataclass
class BacktestResult:
    """Results from a backtest run."""
    initial_capital: float
    final_value: float
    trades: list[Trade]
    portfolio_values: pd.Series  # Time series of portfolio values

    @property
    def total_return(self) -> float:
        """Total return as a decimal (e.g., 0.15 for 15%)."""
        return (self.final_value - self.initial_capital) / self.initial_capital

    @property
    def total_return_pct(self) -> float:
        """Total return as a percentage."""
        return self.total_return * 100

    @property
    def num_trades(self) -> int:
        """Total number of trades executed."""
        return len(self.trades)
